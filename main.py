import os
import tempfile
import pyzipper
from telegram import Update, InputFile
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters, ConversationHandler
import logging
from typing import Dict

# ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù„Ø§Ú¯
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

BOT_TOKEN = os.getenv("BOT_TOKEN")
CHANNEL_USERNAME = "@flvst1"  # ÛŒÙˆØ²Ø±Ù†ÛŒÙ… Ú©Ø§Ù†Ø§Ù„/Ú¯Ø±ÙˆÙ‡ Ø¨Ø¯ÙˆÙ† @
CHANNEL_ID = -1001093039800  # Ø¢ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ Ú©Ø§Ù†Ø§Ù„/Ú¯Ø±ÙˆÙ‡ (Ù…Ù†ÙÛŒ Ø¨Ø§Ø´Ø¯)

# Ø­Ø§Ù„Øªâ€ŒÙ‡Ø§ÛŒ Ú¯ÙØªÚ¯Ùˆ
WAITING_PASSWORD, WAITING_FILES = range(2)
user_data: Dict[int, Dict] = {}

HELP_TEXT = f"""Ø³Ù„Ø§Ù…ğŸ‘‹ 
ğŸ“¦Ø¨Ø§Øª ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø² Ø±Ù…Ø²Ø¯Ø§Ø±

ğŸ“Œ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¨Ø§Øª Ø§Ø¨ØªØ¯Ø§ Ø¨Ø§ÛŒØ¯ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ù…Ø§ Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯:
{CHANNEL_USERNAME}

âœ… Ù¾Ø³ Ø§Ø² Ø¹Ø¶ÙˆÛŒØªØŒ Ø§Ø² Ø¯Ø³ØªÙˆØ±Ø§Øª Ø²ÛŒØ± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯:

1. Ø¯Ø³ØªÙˆØ± /zip Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯
2. Ø±Ù…Ø² Ø¯Ù„Ø®ÙˆØ§Ù‡ Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ù†Ù…Ø§ÛŒÛŒØ¯
3. ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ¯ Ø±Ø§ ÛŒÚ©ÛŒ Ù¾Ø³ Ø§Ø² Ø¯ÛŒÚ¯Ø±ÛŒ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯
4. Ù¾Ø³ Ø§Ø² Ø§ØªÙ…Ø§Ù… Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ØŒ Ø¯Ø³ØªÙˆØ± /done Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯

âš ï¸ Ø­Ø¯Ø§Ú©Ø«Ø± Ø­Ø¬Ù… Ù‡Ø± ÙØ§ÛŒÙ„: 20 Ù…Ú¯Ø§Ø¨Ø§ÛŒØª (Ù…Ø­Ø¯ÙˆØ¯ÛŒØª ØªÙ„Ú¯Ø±Ø§Ù…)
âš ï¸ Ø­Ø¯Ø§Ú©Ø«Ø± ØªØ¹Ø¯Ø§Ø¯ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø¯Ø± ÛŒÚ© Ø¢Ø±Ø´ÛŒÙˆ: 10 ÙØ§ÛŒÙ„"""

async def check_membership(user_id: int, context: ContextTypes.DEFAULT_TYPE) -> bool:
    """Ú†Ú© Ú©Ø±Ø¯Ù† Ø¹Ø¶ÙˆÛŒØª Ú©Ø§Ø±Ø¨Ø± Ø¯Ø± Ú©Ø§Ù†Ø§Ù„"""
    try:
        member = await context.bot.get_chat_member(chat_id=CHANNEL_ID, user_id=user_id)
        return member.status in ['member', 'administrator', 'creator']
    except Exception as e:
        logger.error(f"Error checking membership: {e}")
        return False

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Ú†Ú© Ø¹Ø¶ÙˆÛŒØª
    if not await check_membership(user_id, context):
        await update.message.reply_text(
            f"âŒ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¨Ø§Øª Ø¨Ø§ÛŒØ¯ Ø§Ø¨ØªØ¯Ø§ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ù…Ø§ Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯:\n"
            f"{CHANNEL_USERNAME}\n\n"
            f"âœ… Ù¾Ø³ Ø§Ø² Ø¹Ø¶ÙˆÛŒØªØŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ /start Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
        )
        return
    
    await update.message.reply_text(HELP_TEXT)

async def zip_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Ú†Ú© Ø¹Ø¶ÙˆÛŒØª
    if not await check_membership(user_id, context):
        await update.message.reply_text(
            f"âŒ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¨Ø§Øª Ø¨Ø§ÛŒØ¯ Ø§Ø¨ØªØ¯Ø§ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ù…Ø§ Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯:\n"
            f"{CHANNEL_USERNAME}\n\n"
            f"âœ… Ù¾Ø³ Ø§Ø² Ø¹Ø¶ÙˆÛŒØªØŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."
        )
        return ConversationHandler.END
    
    user_data[user_id] = {'files': [], 'password': None}
    
    await update.message.reply_text("Ù„Ø·ÙØ§Ù‹ Ø±Ù…Ø² Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø¨Ø±Ø§ÛŒ ÙØ§ÛŒÙ„ Ø²ÛŒÙ¾ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
    return WAITING_PASSWORD

async def receive_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Ú†Ú© Ø¹Ø¶ÙˆÛŒØª
    if not await check_membership(user_id, context):
        await update.message.reply_text(
            f"âŒ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¨Ø§Øª Ø¨Ø§ÛŒØ¯ Ø§Ø¨ØªØ¯Ø§ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ù…Ø§ Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯:\n"
            f"{CHANNEL_USERNAME}\n\n"
            f"âœ… Ù¾Ø³ Ø§Ø² Ø¹Ø¶ÙˆÛŒØªØŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."
        )
        return ConversationHandler.END
    
    password = update.message.text.strip()
    
    if not password:
        await update.message.reply_text("Ø±Ù…Ø² Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®Ø§Ù„ÛŒ Ø¨Ø§Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ø±Ù…Ø² Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
        return WAITING_PASSWORD
    
    user_data[user_id]['password'] = password
    
    await update.message.reply_text(
        f"Ø±Ù…Ø² '{password}' Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯.\n"
        "Ù„Ø·ÙØ§Ù‹ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯. Ù¾Ø³ Ø§Ø² Ø§ØªÙ…Ø§Ù…ØŒ Ø¯Ø³ØªÙˆØ± /done Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
    )
    return WAITING_FILES

async def receive_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Ú†Ú© Ø¹Ø¶ÙˆÛŒØª
    if not await check_membership(user_id, context):
        await update.message.reply_text(
            f"âŒ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¨Ø§Øª Ø¨Ø§ÛŒØ¯ Ø§Ø¨ØªØ¯Ø§ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ù…Ø§ Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯:\n"
            f"{CHANNEL_USERNAME}\n\n"
            f"âœ… Ù¾Ø³ Ø§Ø² Ø¹Ø¶ÙˆÛŒØªØŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."
        )
        return ConversationHandler.END
    
    if user_id not in user_data or user_data[user_id]['password'] is None:
        await update.message.reply_text("Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ Ø¯Ø³ØªÙˆØ± /zip Ø±Ø§ Ø§Ø¬Ø±Ø§ Ú©Ù†ÛŒØ¯.")
        return ConversationHandler.END
    
    if len(user_data[user_id]['files']) >= 10:
        await update.message.reply_text("Ø­Ø¯Ø§Ú©Ø«Ø± ØªØ¹Ø¯Ø§Ø¯ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ (10) Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ /done Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.")
        return WAITING_FILES
    
    try:
        document = update.message.document
        file = await document.get_file()
        
        # Ø§ÛŒØ¬Ø§Ø¯ Ù¾ÙˆØ´Ù‡ Ù…ÙˆÙ‚Øª Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ ÙØ§ÛŒÙ„
        with tempfile.NamedTemporaryFile(delete=False) as temp_file:
            await file.download_to_drive(temp_file.name)
            user_data[user_id]['files'].append({
                'name': document.file_name,
                'path': temp_file.name
            })
        
        remaining = 10 - len(user_data[user_id]['files'])
        await update.message.reply_text(
            f"ÙØ§ÛŒÙ„ '{document.file_name}' Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. ({remaining} ÙØ§ÛŒÙ„ Ø¯ÛŒÚ¯Ø± Ù‚Ø§Ø¨Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø§Ø³Øª)\n"
            "ÙØ§ÛŒÙ„ Ø¨Ø¹Ø¯ÛŒ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯ ÛŒØ§ Ø¨Ø±Ø§ÛŒ Ø§ØªÙ…Ø§Ù… /done Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
        )
        return WAITING_FILES
    except Exception as e:
        logger.error(f"Error receiving file: {e}")
        await update.message.reply_text("Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯.")
        return WAITING_FILES

async def done_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Ú†Ú© Ø¹Ø¶ÙˆÛŒØª
    if not await check_membership(user_id, context):
        await update.message.reply_text(
            f"âŒ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¨Ø§Øª Ø¨Ø§ÛŒØ¯ Ø§Ø¨ØªØ¯Ø§ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ù…Ø§ Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯:\n"
            f"{CHANNEL_USERNAME}\n\n"
            f"âœ… Ù¾Ø³ Ø§Ø² Ø¹Ø¶ÙˆÛŒØªØŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯."
        )
        return ConversationHandler.END
    
    if user_id not in user_data or not user_data[user_id]['files']:
        await update.message.reply_text("Ù‡ÛŒÚ† ÙØ§ÛŒÙ„ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.")
        return ConversationHandler.END
    
    try:
        await update.message.reply_text("Ø¯Ø± Ø­Ø§Ù„ Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ Ø²ÛŒÙ¾... Ù„Ø·ÙØ§Ù‹ Ù…Ù†ØªØ¸Ø± Ø¨Ù…Ø§Ù†ÛŒØ¯.")
        
        # Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ Ø²ÛŒÙ¾ Ø±Ù…Ø²Ø¯Ø§Ø±
        with tempfile.NamedTemporaryFile(suffix='.zip', delete=False) as zip_file:
            with pyzipper.AESZipFile(
                zip_file.name, 
                'w', 
                compression=pyzipper.ZIP_DEFLATED,
                encryption=pyzipper.WZ_AES
            ) as zf:
                zf.setpassword(user_data[user_id]['password'].encode('utf-8'))
                
                for file_info in user_data[user_id]['files']:
                    zf.write(file_info['path'], file_info['name'])
            
            # Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„ Ø²ÛŒÙ¾
            zip_file.seek(0)
            await update.message.reply_document(
                document=InputFile(zip_file, filename='archive.zip'),
                caption=f"ÙØ§ÛŒÙ„ Ø²ÛŒÙ¾ Ø¨Ø§ Ø±Ù…Ø² '{user_data[user_id]['password']}' Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯.\n\n"
                        f"âœ… Ø§Ø² Ø­Ù…Ø§ÛŒØª Ø´Ù…Ø§ Ù…ØªØ´Ú©Ø±ÛŒÙ…! {CHANNEL_USERNAME}"
            )
        
        # Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙ‚Øª
        for file_info in user_data[user_id]['files']:
            try:
                os.unlink(file_info['path'])
            except:
                pass
        try:
            os.unlink(zip_file.name)
        except:
            pass
        
        await update.message.reply_text(
            "âœ… ÙØ§ÛŒÙ„ Ø²ÛŒÙ¾ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯!\n\n"
            f"ğŸ’š Ø§Ø² Ú©Ø§Ù†Ø§Ù„ Ù…Ø§ Ø­Ù…Ø§ÛŒØª Ú©Ù†ÛŒØ¯: {CHANNEL_USERNAME}"
        )
        
    except Exception as e:
        logger.error(f"Error creating zip: {e}")
        await update.message.reply_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ Ø²ÛŒÙ¾. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯.")
    
    finally:
        # Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡ Ú©Ø§Ø±Ø¨Ø±
        if user_id in user_data:
            del user_data[user_id]
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙ‚Øª
    if user_id in user_data:
        for file_info in user_data[user_id]['files']:
            try:
                os.unlink(file_info['path'])
            except:
                pass
        del user_data[user_id]
    
    await update.message.reply_text("Ø¹Ù…Ù„ÛŒØ§Øª Ú©Ù†Ø³Ù„ Ø´Ø¯.")
    return ConversationHandler.END

async def check_subscription(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø³ØªÙˆØ± Ø¨Ø±Ø§ÛŒ Ú†Ú© Ú©Ø±Ø¯Ù† Ø¹Ø¶ÙˆÛŒØª"""
    user_id = update.effective_user.id
    
    if await check_membership(user_id, context):
        await update.message.reply_text(
            "âœ… Ø´Ù…Ø§ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø¹Ø¶Ùˆ Ù‡Ø³ØªÛŒØ¯!\n\n"
            "Ø§Ú©Ù†ÙˆÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø² Ø¨Ø§Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯:\n"
            "/zip - Ø´Ø±ÙˆØ¹ ÙØ±Ø¢ÛŒÙ†Ø¯ ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ"
        )
    else:
        await update.message.reply_text(
            f"âŒ Ø´Ù…Ø§ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø¹Ø¶Ùˆ Ù†ÛŒØ³ØªÛŒØ¯!\n\n"
            f"Ù„Ø·ÙØ§Ù‹ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ù…Ø§ Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯:\n"
            f"{CHANNEL_USERNAME}\n\n"
            f"Ø³Ù¾Ø³ Ø¯ÙˆØ¨Ø§Ø±Ù‡ /check Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
        )

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Error: {context.error}")
    if update and update.message:
        await update.message.reply_text("âŒ Ø®Ø·Ø§ÛŒÛŒ Ø±Ø® Ø¯Ø§Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯.")

def main():
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN environment variable is required")
        raise ValueError("BOT_TOKEN environment variable is required")
    
    if not CHANNEL_USERNAME or not CHANNEL_ID:
        logger.error("CHANNEL_USERNAME and CHANNEL_ID must be set")
        raise ValueError("CHANNEL_USERNAME and CHANNEL_ID must be set")
    
    try:
        application = Application.builder().token(BOT_TOKEN).build()
        
        # handlers
        conv_handler = ConversationHandler(
            entry_points=[CommandHandler('zip', zip_command)],
            states={
                WAITING_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_password)],
                WAITING_FILES: [
                    MessageHandler(filters.Document.ALL, receive_file),
                    CommandHandler('done', done_command)
                ],
            },
            fallbacks=[CommandHandler('cancel', cancel)],
        )
        
        application.add_handler(CommandHandler('start', start))
        application.add_handler(CommandHandler('check', check_subscription))
        application.add_handler(conv_handler)
        application.add_error_handler(error_handler)
        
        logger.info("Bot is starting...")
        print("ğŸ¤– Bot is starting with mandatory subscription...")
        application.run_polling()
        
    except Exception as e:
        logger.error(f"Failed to start bot: {e}")
        print(f"âŒ Failed to start bot: {e}")

if __name__ == "__main__":
    main()
